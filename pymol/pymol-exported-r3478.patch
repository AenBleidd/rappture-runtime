diff -wb -u -r ../pymol/contrib/uiuc/plugins/molfile_plugin/src/periodic_table.h ./contrib/uiuc/plugins/molfile_plugin/src/periodic_table.h
--- ../pymol/contrib/uiuc/plugins/molfile_plugin/src/periodic_table.h	2008-11-12 11:39:56.000000000 -0500
+++ ./contrib/uiuc/plugins/molfile_plugin/src/periodic_table.h	2008-11-12 12:09:26.000000000 -0500
@@ -72,7 +72,9 @@
     /* Na */ 2.27, 1.73, 2.0, 2.1, 1.8,
     /* S  */ 1.8, 1.75, 1.88, 2.75, 2.0, 2.0,
     /* Ti */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,
-    /* Ni */ 1.63, 1.4, 1.39, 1.07, 2.0, 1.85,
+    /* PYMOLSERVER */
+    /* Ni */ 1.63, 1.4, 1.39, 1.87, 2.0, 1.85, /* gah - changed radius */
+    /* PYMOLSERVER */
     /* Se */ 1.9, 1.85, 2.02, 2.0, 2.0, 2.0, 
     /* Zr */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,
     /* Pd */ 1.63, 1.72, 1.58, 1.93, 2.17, 2.0, 
diff -wb -u -r ../pymol/layer0/MyPNG.c ./layer0/MyPNG.c
--- ../pymol/layer0/MyPNG.c	2008-11-12 11:39:32.000000000 -0500
+++ ./layer0/MyPNG.c	2008-11-12 12:09:26.000000000 -0500
@@ -48,9 +48,232 @@
 #include"MemoryDebug.h"
 #include "Setting.h"
 
+/* PYMOLSERVER */
+/*
+ * Persistent image capture buffer *NJK*.  
+ *
+ * We make image buffer a pymol global to reduce time spent allocating and
+ * reallocating memory for image captures.
+ */
+struct _CImage {
+    void *data;
+    int   allocated;
+    int   used;
+};
 
-int MyPNGWrite(PyMOLGlobals *G,char *file_name,unsigned char *p,
-               unsigned int width,unsigned int height,float dpi)
+int 
+ImageInit(PyMOLGlobals *G)
+{
+    CImage *I;
+
+    I = G->Image=Calloc(CImage,1);
+    if (I != NULL) {
+	UtilZeroMem(I,sizeof(CImage));
+	I->data = NULL;
+	I->used = 0;
+	I->allocated = 0;
+	return 1;
+    }
+    return 0;
+}
+
+/* BMP save image support *NJK* */
+static void
+bmp_header_add_int(unsigned char* header, unsigned int pos, unsigned int data)
+{ 
+    header[pos++] = data & 0xff;
+    header[pos++] = (data >> 8) & 0xff;
+    header[pos++] = (data >> 16) & 0xff;
+    header[pos++] = (data >> 24) & 0xff;
+} 
+
+static void
+bmp_header_add_short(unsigned char* header, unsigned int pos, 
+		     unsigned short data)
+{ 
+    header[pos++] = data & 0xff;
+    header[pos++] = (data >> 8) & 0xff;
+} 
+ 
+int 
+MyBMPWrite(PyMOLGlobals *G, char *bmp, unsigned char *save_image, int width, 
+	   int height, float dpi)
+{ 
+    unsigned char header[54];
+    int pos = 0;
+    int pad = 0;
+    int fsize = 0;
+    int row = 0;
+    int col = 0;
+    unsigned char *scr;
+    unsigned char *src = save_image;
+    unsigned char tmp; 
+    struct _CImage *data = G->Image;
+    
+    if ((3 * width) % 4 > 0)
+	pad = 4 - ((3 * width) % 4);
+    
+    header[pos++] = 'B';
+    header[pos++] = 'M';
+    
+    /* file size in bytes */
+    fsize = (3 * width + pad) * height + sizeof(header);
+    bmp_header_add_int(header,pos,fsize);
+    pos+=4;
+    
+    /* reserved value (must be 0) */
+    bmp_header_add_int(header, pos, 0);
+    pos+=4;
+    
+    /* offset in bytes to start of bitmap data */
+    bmp_header_add_int(header, pos, sizeof(header));
+    pos+=4;
+    
+    /* size of the BITMAPINFOHEADER */
+    bmp_header_add_int(header, pos, 40);
+    pos+=4;
+    
+    /* width of the image in pixels */
+    bmp_header_add_int(header, pos, width);
+    pos+=4;
+    
+    /* height of the image in pixels */
+    bmp_header_add_int(header, pos, height);
+    pos+=4;
+    
+    /* 1 plane */
+    bmp_header_add_short(header, pos, 1);
+    pos+=2;
+    
+    /* 24 bits/pixel */
+    bmp_header_add_short(header, pos, 24);
+    pos+=2;
+    
+    /* no compression */
+    /* size of image for compression */
+    
+    bmp_header_add_int(header, pos, 0);
+    pos+=4;
+    bmp_header_add_int(header, pos, 0);
+    pos+=4;
+    
+    /* x pixels per meter */
+    /* y pixels per meter */
+    bmp_header_add_int(header, pos, 0);
+    pos+=4;
+    bmp_header_add_int(header, pos, 0);
+    pos+=4;
+    
+    /* number of colors used (0 = compute from bits/pixel) */
+    /* number of important colors (0 = all colors important) */
+    bmp_header_add_int(header, pos, 0);
+    pos+=4;
+    bmp_header_add_int(header, pos, 0);
+    pos+=4;
+    
+    if (data->allocated < fsize) {
+  	char *newdata;
+	
+	newdata = realloc(data->data, fsize);
+	
+	if (newdata) {
+	    data->data = newdata;
+	    data->allocated = fsize;
+	}
+    }
+    
+    if (data->allocated < fsize) {
+	return 0;
+    }
+    scr = data->data;
+    
+    for (row=0; row < height; row++) {
+	for (col=0; col < width; col++) {
+	    tmp = src[0];
+	    scr[0] = src[2];
+	    scr[1] = src[1];
+	    scr[2] = tmp;
+	    scr += 3;
+	    src += 4;
+	}
+	scr += pad;  /* skip over padding already in screen data */
+    }
+
+    if (strcmp(bmp,"-.bmp") == 0) {
+	/* Sample counting patch *NJK* */
+	fprintf(stdout,"image follows: %d\n",fsize);
+	fwrite(header, sizeof(header), 1, stdout);
+	fwrite(data->data, 1, fsize - sizeof(header), stdout);
+	fflush(stdout);
+    } else {
+	FILE *fp;
+
+	if(bmp[0] == 1) {
+	    int fd;
+	    if (sscanf(bmp+1, "%d", &fd) == 1) {
+		fp = fdopen(fd, "wb");
+	    }
+	} else {
+	    fp = fopen(bmp,"wb");
+	}
+	if (fp != NULL) {
+	    fwrite(header, sizeof(header), 1, fp);
+	    fwrite(data->data, 1, fsize - sizeof(header), fp);
+	    fflush(fp);
+	    fclose(fp);
+	}
+    }
+    return 1;
+}
+
+#ifdef _PYMOL_LIBPNG
+/* PNG stdout support *NJK */
+/* add ability to write PNG files to standard output        */
+/* we have to write to memory first so we can inform client */
+/* how much data is going to be sent                        */
+
+static void
+user_write_data(png_structp png_ptr, png_bytep buf, png_size_t length)
+{
+    voidp write_io_ptr;
+    struct _CImage *data;
+    int available;
+    
+    write_io_ptr = png_get_io_ptr(png_ptr);
+    data = write_io_ptr;
+    available = data->allocated - data->used;
+    
+    if (length > available) {
+	unsigned char *newdata;
+	int needed;
+
+	needed = length - available;
+
+	if (needed < 32768) {
+	    needed = 32768;
+	}
+	newdata = realloc(data->data, data->allocated + needed);
+	if (newdata == NULL) {
+	    return;
+	}
+	data->data = newdata;
+	data->allocated += needed;
+    }
+    memcpy((unsigned char *)data->data + data->used, buf, length);
+    data->used += length;
+    return;
+}
+
+static void
+user_flush_data(png_structp png_ptr)
+{
+    return;
+}
+#endif /* _PYMOL_LIBPNG */
+
+/* PYMOLSERVER */
+
+int MyPNGWrite(PyMOLGlobals *G,char *file_name,unsigned char *p,unsigned int width,unsigned int height,float dpi)
 {
 #ifdef _PYMOL_LIBPNG
   int ok=true;
@@ -68,6 +291,12 @@
   
   /* open the file, allowing use of an encoded file descriptor, with
      approach adapted from TJO: chr(1) followed by ascii-format integer */
+
+  /* PYMOLSERVER */
+  if(strcmp(file_name, "-.png") == 0) {	 
+      fp = stdout;		/* PNG stdout support */
+  } else {
+  /* PYMOLSERVER */
   if(file_name[0] == 1) {
     if( sscanf(file_name+1, "%d", &fd) == 1) {
       fp = fdopen(fd, "wb");
@@ -82,6 +311,8 @@
     ok=false;
     goto cleanup;
   }
+  }
+
    /* Create and initialize the png_struct with the desired error handler
     * functions.  If you want to use the default stderr and longjump method,
     * you can supply NULL for the last three parameters.  We also check that
@@ -114,7 +345,14 @@
    }
 
    /* set up the output control if you are using standard C streams */
+   /* PYMOLSERVER */
+   if(fp == stdout) {		/* PNG stdout support *NJK* */
+      G->Image->used = 0;
+      png_set_write_fn(png_ptr, G->Image, user_write_data, user_flush_data);
+   } else {
+   /* PYMOLSERVER */
    png_init_io(png_ptr, fp);
+   }
 
    /* Set the image information here.  Width and height are up to 2^31,
     * bit_depth is one of 1, 2, 4, 8, or 16, but valid values also depend on
@@ -132,6 +370,9 @@
      png_set_pHYs(png_ptr, info_ptr, dots_per_meter, dots_per_meter, PNG_RESOLUTION_METER);
    }
 
+   /* PYMOLSERVER */
+   png_set_compression_level(png_ptr,1); /* PNG stdout support *NJK* */
+   /* PYMOLSERVER */
 
    png_set_gamma(png_ptr, SettingGet(G,cSetting_png_screen_gamma), 
                  SettingGet(G,cSetting_png_file_gamma));
@@ -176,11 +417,20 @@
    png_destroy_write_struct(&png_ptr, (png_infopp)NULL);
 
  cleanup:
+
+   /* PYMOLSERVER */
+   if (fp == stdout) {
+       /* Stdout image patch *NJK */
+       fprintf(fp, "image follows: %d\n", G->Image->used);
+       fwrite(G->Image->data, sizeof(char), G->Image->used, fp);
+       fflush(fp);
+       G->Image->used = 0;
+   } else {
+   /* PYMOLSERVER */
    if(fp) {
-     /* close the file */
      fclose(fp);
    }
-   
+   }
    mfree(row_pointers);
    /* that's it */
 
@@ -188,7 +438,7 @@
 #else
 
    return 0;
-#endif
+#endif /* _PYMOL_LIBPNG */
 }
 
 int MyPNGRead(char *file_name,unsigned char **p_ptr,unsigned int *width_ptr,unsigned int *height_ptr)
@@ -357,15 +607,7 @@
    return(ok);
 #else
    return (false);
-#endif
+#endif /* _PYMOL_LIBPNG */
   
 } /* end of source */
 
-
-
-
-
-
-
-
-
diff -wb -u -r ../pymol/layer0/PyMOLGlobals.h ./layer0/PyMOLGlobals.h
--- ../pymol/layer0/PyMOLGlobals.h	2008-11-12 11:39:32.000000000 -0500
+++ ./layer0/PyMOLGlobals.h	2008-11-12 12:09:26.000000000 -0500
@@ -54,6 +54,11 @@
 typedef struct _CMain CMain;
 typedef struct _CPlugIOManager CPlugIOManager;
 
+/* PYMOLSERVER */
+/* Persistent image capture buffer *NJK* */
+typedef struct _CImage CImage; 
+/*PYMOLSERVER*/
+
 #ifndef _PYMOL_NOPY
 typedef struct _CP_inst CP_inst;
 #endif
@@ -161,7 +166,10 @@
 
   int DragDirtyFlag; /* do we need an extra callback to handle a mouse drag? */
 
-
+  /* PYMOLSERVER */
+  int CmdPipe[2]; /* Sleep Interruption Patch *NJK* */
+  CImage *Image;  /* Persistent image capture buffer *NJK* */
+  /* PYMOLSERVER */
 };
 
 /* if we're running PyMOL as a global singleton (old way / backward
diff -wb -u -r ../pymol/layer1/Ortho.c ./layer1/Ortho.c
--- ../pymol/layer1/Ortho.c	2008-11-12 11:39:46.000000000 -0500
+++ ./layer1/Ortho.c	2008-11-12 12:09:26.000000000 -0500
@@ -2025,9 +2025,15 @@
 /*========================================================================*/
 void OrthoCommandIn(PyMOLGlobals *G,char *buffer)
 {
+  /* PYMOLSERVER */
+  char c = 1;			/* Sleep Interruption Patch *NJK* */
+  /* PYMOLSERVER */
   register COrtho *I=G->Ortho;
   if(I->cmdActiveQueue)
 	QueueStrIn(I->cmdActiveQueue,buffer);
+  /* PYMOLSERVER */
+  write(G->CmdPipe[1], &c, 1);	/* Sleep Interruption Patch *NJK* */
+  /* PYMOLSERVER */
 }
 /*========================================================================*/
 void OrthoPasteIn(PyMOLGlobals *G,char *buffer)
Only in ./layer1: Ortho.c.orig
diff -wb -u -r ../pymol/layer1/P.c ./layer1/P.c
--- ../pymol/layer1/P.c	2008-11-12 11:39:46.000000000 -0500
+++ ./layer1/P.c	2008-11-12 12:09:26.000000000 -0500
@@ -399,13 +399,26 @@
 void PSleepUnlocked(PyMOLGlobals *G,int usec)
 { /* can only be called by the glut process */
 #ifndef WIN32
+  /*PYMOLSERVER */
+  fd_set fds;			/* Sleep Interruption Patch *NJK* */
+  /*PYMOLSERVER*/
   struct timeval tv;
   PRINTFD(G,FB_Threads)
     " PSleep-DEBUG: napping.\n"
     ENDFD;
   tv.tv_sec=0;
   tv.tv_usec=usec; 
-  select(0,NULL,NULL,NULL,&tv);
+
+  /* PYMOLSERVER */
+  /* Sleep Interruption Patch *NJK* */
+  FD_ZERO(&fds);
+  FD_SET(SingletonPyMOLGlobals->CmdPipe[0], &fds);
+  select(SingletonPyMOLGlobals->CmdPipe[0]+1, &fds, NULL, NULL, &tv);
+  if (FD_ISSET(SingletonPyMOLGlobals->CmdPipe[0],&fds)) {
+      char c;
+      read(SingletonPyMOLGlobals->CmdPipe[0], &c, 1);
+  }
+  /*PYMOLSERVER*/
   PRINTFD(G,FB_Threads)
     " PSleep-DEBUG: nap over.\n"
     ENDFD;
diff -wb -u -r ../pymol/layer1/Scene.c ./layer1/Scene.c
--- ../pymol/layer1/Scene.c	2008-11-12 11:39:46.000000000 -0500
+++ ./layer1/Scene.c	2008-11-12 12:09:26.000000000 -0500
@@ -1985,6 +1985,8 @@
   SceneImageFinish(G,image);  
   return (image!=NULL);
 }
+
+
 /*========================================================================*/
 void ScenePerspective(PyMOLGlobals *G,int flag)
 {
@@ -5500,6 +5502,88 @@
   return(1);
 }
 
+/* PYMOLSERVER */
+
+/* BMP save image support *NJK* */
+int 
+SceneBMP(PyMOLGlobals *G, char *bmp, float dpi, int quiet, int prior_only)
+{
+    register CScene *I=G->Scene;
+    
+    GLvoid *image = SceneImagePrepare(G,prior_only);
+    if(image && I->Image) {
+	int width = I->Image->width;
+	int height = I->Image->height;
+	unsigned char *save_image = image;
+	
+	if((image==I->Image->data) && I->Image->stereo) {
+	    width = I->Image->width;
+	    save_image = Alloc(unsigned char, I->Image->size*2);
+	    interlace((unsigned int*)save_image,
+		      (unsigned int*)I->Image->data,width,height);
+	    width *= 2;
+	}
+	if (dpi<0.0F) 
+	    dpi = SettingGetGlobal_f(G,cSetting_image_dots_per_inch);
+	if (MyBMPWrite(G, bmp, save_image, width, height, dpi)) {
+	    if(!quiet) {
+		PRINTFB(G,FB_Scene,FB_Actions)
+		    " SceneBMP: wrote %dx%d pixel image to file \"%s\".\n",
+		    width, I->Image->height, bmp
+		    ENDFB(G);
+	    }
+	} else {
+	    PRINTFB(G,FB_Scene,FB_Errors)
+		" SceneBMP-Error: error writing \"%s\"! Please check directory...\n",
+		bmp
+		ENDFB(G);
+	}
+	if(save_image && (save_image!=image))
+	    FreeP(save_image);
+    }
+    SceneImageFinish(G,image);
+    return (image != NULL);
+}
+
+/* BMP save image support *NJK* */
+static int 
+SceneDeferredBMPImage(DeferredImage *di) 
+{
+    PyMOLGlobals *G=di->G;
+    SceneMakeSizedImage(G,di->width, di->height,di->antialias);
+    if(di->filename) {
+	SceneBMP(G,di->filename, di->dpi, di->quiet, false);
+	FreeP(di->filename);
+    }
+    return 1;
+}
+
+/* BMP save image support *NJK* */
+int 
+SceneDeferBMPImage(PyMOLGlobals *G,int width, int height, char *filename, 
+		   int antialias, float dpi, int quiet) 
+{
+  DeferredImage *di = Calloc(DeferredImage,1);
+  if(di) {
+    DeferredInit(G,&di->deferred);
+    di->G = G;
+    di->width = width;
+    di->height = height;
+    di->antialias = antialias;
+    di->deferred.fn = (DeferredFn*)SceneDeferredBMPImage;
+    di->dpi = dpi;
+    di->quiet = quiet;
+    if(filename) {
+      int stlen = strlen(filename);
+      di->filename = Alloc(char,stlen+1);
+      strcpy(di->filename, filename);
+    }
+  }
+  OrthoDefer(G,&di->deferred);
+  return 1;
+}
+/* PYMOLSERVER */
+
 static int SceneDeferredClick(DeferredMouse *dm)
 {
   if(!SceneClick(dm->block, dm->button, dm->x, dm->y, dm->mod, dm->when)) {
diff -wb -u -r ../pymol/layer2/AtomInfo.c ./layer2/AtomInfo.c
--- ../pymol/layer2/AtomInfo.c	2008-11-12 11:39:48.000000000 -0500
+++ ./layer2/AtomInfo.c	2008-11-12 12:09:26.000000000 -0500
@@ -30,6 +30,10 @@
 #include"OVContext.h"
 #include"PyMOLObject.h"
 
+/*PYMOLSERVER*/
+static int RapptureGetVDWRadius(const char *symbol, float *radiusPtr);
+/*PYMOLSERVER*/
+
 struct _CAtomInfo {
   int NColor,CColor,DColor,HColor,OColor,SColor;
   int BrColor, ClColor, FColor, IColor;
@@ -2863,9 +2867,16 @@
   case cAN_Pb: vdw=2.02F; break;
 
   case cAN_U:  vdw=1.86F; break;
-
-  case cAN_LP: vdw=0.5F; break; /* lone pairs @ 0.5 same as MOE? */
-
+  /*PYMOLSERVER*/
+  case cAN_LP: 
+      vdw=1.70F; break; 
+      /* 
+       * gah@purdue.edu:  Try setting default radius to 1.7 (same as carbon). 
+       *		  Previous setting of 0.5 is too small (especially 
+       *		  with 0.25 sphere scale). 
+       */
+      /* lone pairs @ 0.5 same as MOE? */
+  /*PYMOLSERVER*/
   default: vdw=1.80F; break; /* default radius for known atoms with unknown radii */
   }
   
@@ -2881,6 +2892,11 @@
     if(!strcmp(e,"F")) vdw=1.35F;
     if(!strcmp(e,"H")) vdw=1.1F;
   }
+  /*PYMOLSERVER*/
+  /* This routine overrides the current radius value if it can find a matching
+   * element symbol. */
+  RapptureGetVDWRadius(e, &vdw);
+  /*PYMOLSERVER*/
 
   if(I->vdw==0.0) /* only assigned if not yet assigned */
     I->vdw = vdw;
@@ -2895,3 +2911,95 @@
   /*  printf("I->name %s I->priority %d\n",I->name,I->priority);*/
 }
   
+/*PYMOLSERVER*/
+/* 
+ *
+ * RapptureGetVDWRadius --
+ *
+ *	Get the van der Waals radius of the atom given the element symbol
+ *	(e.g. "Pb"). The values are taken from wikipedia (reference
+ *	http://www.webelements.com).
+ *
+ *	gah@purdue.edu: Several atoms (e.g. Ga, As) did not have a van der
+ *	Waals radius listed by default in pymol.  They defaulted to 0.5.  That
+ *	in conjunction with the setting of sphere_scale to 0.25 made the
+ *	spheres for these atoms too tiny to see.
+ *
+ *	Performs a binary search to lookup symbols and their corresponding
+ *	radii.
+ */
+struct VdwRadii {
+    char *symbol;
+    float radius;
+};
+
+static struct VdwRadii vdwRadii[] = {
+    /* The rows in the this table must be sorted alphabetically low to high by
+     * the element symbol. */
+    "Ag", 	1.72f,
+    "Ar", 	1.88f,
+    "As", 	1.85f,
+    "Au", 	1.66f,
+    "Br", 	1.85f,
+    "C", 	1.70f,
+    "Cd", 	1.58f,
+    "Cl", 	1.75f,
+    "Cu", 	1.40f,
+    "F", 	1.47f,
+    "Ga", 	1.87f,
+    "H", 	1.20f, 	
+    "He", 	1.40f, 	
+    "Hg", 	1.55f,
+    "I", 	1.98f,
+    "In", 	1.93f,
+    "K", 	2.75f,
+    "Kr", 	2.02f,
+    "Li", 	1.82f,
+    "Mg", 	1.73f,
+    "N", 	1.55f,
+    "Na", 	2.27f,
+    "Ne", 	1.54f,
+    "Ni", 	1.63f,
+    "O", 	1.52f,
+    "P", 	1.80f,
+    "Pb", 	2.02f,
+    "Pd", 	1.63f,
+    "Pt", 	1.75f,
+    "S", 	1.80f,
+    "Se", 	1.90f,
+    "Si", 	2.10f,
+    "Sn", 	2.17f,
+    "Te", 	2.06f,
+    "Tl", 	1.96f,
+    "U", 	1.86f,
+    "Xe", 	2.16f,
+    "Zn", 	1.39f,
+};
+
+static int nVdwRadii = sizeof(vdwRadii) / sizeof(struct VdwRadii);
+
+static int
+RapptureGetVDWRadius(const char *symbol, float *radiusPtr) 
+{
+    int low, high;
+    
+    low = 0;
+    high = nVdwRadii - 1;
+    while (low <= high) {
+	int median, result;
+
+	median = (low + high) >> 1;
+	result = strcmp(symbol, vdwRadii[median].symbol);
+	if (result < 0) {
+	    high = median - 1;
+	} else if (result > 0) {
+	    low = median + 1;
+	} else {
+	    *radiusPtr = vdwRadii[median].radius;
+	    return 1;
+	}
+    }
+    return 0;
+}
+
+/*PYMOLSERVER*/
diff -wb -u -r ../pymol/layer4/Cmd.c ./layer4/Cmd.c
--- ../pymol/layer4/Cmd.c	2008-11-12 11:40:00.000000000 -0500
+++ ./layer4/Cmd.c	2008-11-12 12:09:26.000000000 -0500
@@ -5943,6 +5943,77 @@
   return APIResultCode(result);
 }
 
+/*PYMOLSERVER*/
+/* BMP save image support *NJK* */
+static PyObject *CmdBMP(PyObject *self, PyObject *args) 
+{
+  PyMOLGlobals *G = NULL;
+  char *str1;
+  int ok = false;
+  int quiet;
+  int result = 0;
+  int width,height,ray;
+  int prior;
+  float dpi;
+  ok = PyArg_ParseTuple(args,"Osiifiii",&self,&str1,&width,&height,&dpi,&ray,&quiet,&prior);
+  if(ok) {
+    API_SETUP_PYMOL_GLOBALS;
+    ok = (G!=NULL);
+  } else {
+    API_HANDLE_ERROR;
+  }
+  if(ok && (ok=APIEnterNotModal(G))) {
+    if(prior) {
+      if(SceneBMP(G,str1,dpi,quiet,prior))
+        result = 1; /* signal success by returning 1 instead of 0, or -1 for error  */
+    } else {
+      ExecutiveDrawNow(G);		 /* TODO STATUS */
+      if(ray) {
+        SceneRay(G,width,height,(int)SettingGet(G,cSetting_ray_default_renderer),
+                 NULL,NULL,0.0F,0.0F,false,NULL,true,-1); 
+        ok = SceneBMP(G,str1,dpi,quiet,false);
+      } else if(width||height) {
+        SceneDeferBMPImage(G,width,height,str1,-1,dpi,quiet);
+      } else {
+        ok = SceneBMP(G,str1,dpi,quiet,false);
+      }
+    }
+    APIExit(G);
+  }
+  if(!ok)
+    result = -1;
+  return APIResultCode(result);
+}
+
+/* Virtual Mouse command *NJK* */
+static PyObject *CmdVMouse(PyObject *self,    PyObject *args)
+{
+    PyMOLGlobals *G = NULL;
+    int ok = false;
+    int button, modifier, state, x, y;
+    int quiet;
+    int result = 0;
+    ok = PyArg_ParseTuple(args,"iiiii",&button,&modifier,&state,&x,&y,&quiet);
+    
+    if(ok) {
+	API_SETUP_PYMOL_GLOBALS;
+	ok = (G!=NULL);
+    }
+    if(ok && (ok=APIEnterNotModal(G))) {
+	if ((state == 0) || (state == 1))
+	    ProcessMainButton(button,modifier,state,x,y);
+	else if (state == 2)
+	    ProcessMainDrag(x,y);
+	else if (state == 3)
+	    ProcessMainPassive(x,y);
+	APIExit(G);
+    }
+    if(!ok)
+	result = -1;
+    return APIResultCode(result);
+}
+/*PYMOLSERVER*/
+
 static PyObject *CmdMPNG(PyObject *self, 	PyObject *args)
 {
   PyMOLGlobals *G = NULL;
@@ -8259,6 +8330,10 @@
   {"angle",                 CmdAngle,                METH_VARARGS },
   {"attach",                CmdAttach,               METH_VARARGS },
   {"bg_color",              CmdBackgroundColor,      METH_VARARGS },
+  /*PYMOLSERVER*/
+  /* BMP save image support *NJK* */
+  {"bmp",                   CmdBMP,                  METH_VARARGS }, 
+  /*PYMOLSERVER*/
   {"bond",                  CmdBond,                 METH_VARARGS },
   {"busy_draw",             CmdBusyDraw,             METH_VARARGS },
   {"button",                CmdButton,               METH_VARARGS },
@@ -8493,6 +8568,10 @@
   {"unset",                 CmdUnset,                METH_VARARGS },
   {"unset_bond",            CmdUnsetBond,            METH_VARARGS },
   {"update",                CmdUpdate,               METH_VARARGS },
+  /*PYMOLSERVER*/
+  /* Virtual Mouse command *NJK* */
+  {"vmouse",                CmdVMouse,               METH_VARARGS },
+  /*PYMOLSERVER*/
   {"window",                CmdWindow,               METH_VARARGS },
   {"zoom",	                CmdZoom,                 METH_VARARGS },
   {NULL,		              NULL}     /* sentinel */        
diff -wb -u -r ../pymol/layer5/PyMOL.c ./layer5/PyMOL.c
--- ../pymol/layer5/PyMOL.c	2008-11-12 11:40:00.000000000 -0500
+++ ./layer5/PyMOL.c	2008-11-12 12:09:26.000000000 -0500
@@ -2841,6 +2841,11 @@
       
       result->G->PyMOL = result; /* store the instance pointer */
 
+      /*PYMOLSERVER*/
+      /* Sleep Interruption Patch *NJK* */
+      pipe(result->G->CmdPipe);  
+      /*PYMOLSERVER*/
+
       result->BusyFlag = false;
       result->InterruptFlag = false;
       PyMOL_ResetProgress(result);
@@ -2941,6 +2946,10 @@
   IsosurfInit(G);
   TetsurfInit(G);
   EditorInit(G);
+  /*PYMOLSERVER*/
+  /* Persistent image capture buffer *NJK* */
+  ImageInit(G);		
+  /*PYMOLSERVER*/
 
 #ifdef TRACKER_UNIT_TEST
   TrackerUnitTest(G);
diff -wb -u -r ../pymol/layer5/main.c ./layer5/main.c
--- ../pymol/layer5/main.c	2008-11-12 11:40:00.000000000 -0500
+++ ./layer5/main.c	2008-11-12 12:09:26.000000000 -0500
@@ -569,6 +569,105 @@
   }
 }
 /*========================================================================*/
+/*PYMOLSERVER*/
+/* Virtual mouse support *NJK* */
+void 
+ProcessMainDrag(int x,int y)
+{
+    PyMOLGlobals *G = SingletonPyMOLGlobals;
+    
+    CMain *I = G->Main;
+    
+    y=G->Option->winY-y;
+    
+    PyMOL_Drag(PyMOLInstance,x,y,I->Modifiers);
+    
+    if(PyMOL_GetRedisplay(PyMOLInstance, true)) {
+	if(G->HaveGUI) {
+	    p_glutPostRedisplay();
+	}
+	I->IdleMode = 0;
+    }
+}
+
+/* Virtual mouse support *NJK* */
+void 
+ProcessMainButton(int button,int glMod,int state,int x,int y)
+{
+    PyMOLGlobals *G = SingletonPyMOLGlobals;
+    
+    CMain *I = G->Main;
+    
+    I->IdleMode = 0; /* restore responsiveness */
+    
+    if(PyMOL_GetPassive(PyMOLInstance, true)) {
+	ProcessMainDrag(x,y);
+    } else {
+	/* stay blocked here because Clicks->SexFrame->PParse */
+	
+	y=G->Option->winY-y;
+	
+	I->Modifiers = ((glMod&P_GLUT_ACTIVE_SHIFT) ? cOrthoSHIFT : 0) |
+	    ((glMod&P_GLUT_ACTIVE_CTRL) ? cOrthoCTRL : 0) |
+	    ((glMod&P_GLUT_ACTIVE_ALT) ? cOrthoALT : 0);
+	
+	switch(button) {
+	case P_GLUT_BUTTON_SCROLL_FORWARD:
+	case P_GLUT_BUTTON_SCROLL_BACKWARD:
+	    x=G->Option->winX/2;
+	    y=G->Option->winY/2; /* force into scene */
+	    break;
+	}
+	PyMOL_Button(PyMOLInstance,button,state,x,y,I->Modifiers);
+    }
+}
+
+/* Virtual mouse support *NJK* */
+void 
+ProcessMainPassive(int x,int y)
+{
+    PyMOLGlobals *G = SingletonPyMOLGlobals;
+    CMain *I = G->Main;
+    
+#define PASSIVE_EDGE 20
+    
+    if(PyMOL_GetPassive(G->PyMOL,false)) { /* a harmless race condition -- we
+					    * don't want to slow Python down
+					    * buy locking on passive mouse
+					    * motion */
+	
+	if((y<-PASSIVE_EDGE)||(x<-PASSIVE_EDGE)||
+	   (x>(G->Option->winX+PASSIVE_EDGE))||
+	   (y>(G->Option->winY+PASSIVE_EDGE))) {       
+	    /* release passive drag if mouse leaves window... */
+	    
+	    y=G->Option->winY-y;
+	    
+	    PyMOL_Button(PyMOLInstance,P_GLUT_LEFT_BUTTON, P_GLUT_UP,x,y,
+			 I->Modifiers);
+	    
+	    PyMOL_GetPassive(G->PyMOL,true); /* reset the flag */
+	    
+	} else {
+	    
+	    y=G->Option->winY-y;
+	    
+	    PyMOL_Drag(PyMOLInstance,x,y,I->Modifiers);
+	    
+	}
+	
+	if(PyMOL_GetRedisplay(PyMOLInstance, true)) {
+	    if(G->HaveGUI) {
+		p_glutPostRedisplay();
+	    }      
+	    I->IdleMode = 0;
+	}
+    }
+}
+/*PYMOLSERVER*/
+
+/*========================================================================*/
+
 static void MainButton(int button,int state,int x,int y)
 {
   PyMOLGlobals *G = SingletonPyMOLGlobals;
diff -wb -u -r ../pymol/modules/pymol/api.py ./modules/pymol/api.py
--- ../pymol/modules/pymol/api.py	2008-11-12 11:39:00.000000000 -0500
+++ ./modules/pymol/api.py	2008-11-12 12:09:26.000000000 -0500
@@ -60,6 +60,8 @@
 
 #--------------------------------------------------------------------
 import controlling
+#PYMOLSERVER
+# vmouse adds Virutal mouse support *NJK*
 from controlling import \
       button,             \
       config_mouse,       \
@@ -68,7 +70,9 @@
       order,              \
       set_key,            \
       unmask,             \
+      vmouse,             \
       edit_mode
+#PYMOSERVER
 
 #--------------------------------------------------------------------
 from querying import \
@@ -128,7 +132,10 @@
 
 #--------------------------------------------------------------------
 import exporting
+#PYMOLSERVER
+# bmp adds BMP save image support *NJK*
 from exporting import \
+      bmp,                \
       copy_image,         \
       cache,              \
       export_coords,      \
@@ -137,6 +144,7 @@
       multisave,          \
       png,                \
       save               
+#PYMOLSERVER
 
 #--------------------------------------------------------------------
 import editing
Only in ./modules/pymol: api.py.orig
diff -wb -u -r ../pymol/modules/pymol/cmd.py ./modules/pymol/cmd.py
--- ../pymol/modules/pymol/cmd.py	2008-11-12 11:39:00.000000000 -0500
+++ ./modules/pymol/cmd.py	2008-11-12 12:09:26.000000000 -0500
@@ -192,6 +192,9 @@
         _object_update_spawn = internal._object_update_spawn
         _object_update_thread = internal._object_update_thread
         _png = internal._png
+        # PYMOLSERVER
+        _bmp = internal._bmp
+        # PYMOLSERVER
         _quit = internal._quit
         _ray_anti_spawn = internal._ray_anti_spawn
         _ray_hash_spawn = internal._ray_hash_spawn
diff -wb -u -r ../pymol/modules/pymol/controlling.py ./modules/pymol/controlling.py
--- ../pymol/modules/pymol/controlling.py	2008-11-12 11:39:00.000000000 -0500
+++ ./modules/pymol/controlling.py	2008-11-12 12:09:26.000000000 -0500
@@ -768,3 +768,15 @@
         if _self._raising(r,_self): raise pymol.CmdException         
         return r
 
+#PYMOLSERVER
+    # Virtual mouse support *NJK*
+    def vmouse(b,m,s,x,y,quiet=1,_self=cmd):
+        r = DEFAULT_SUCCESS
+        try:
+            _self.lock(_self)   
+            _cmd.vmouse(int(b),int(m),int(s),int(x),int(y))
+        finally:
+            _self.unlock(r,_self)
+        if _self._raising(r,_self): raise pymol.CmdException         
+        return r
+#PYMOLSERVER
diff -wb -u -r ../pymol/modules/pymol/exporting.py ./modules/pymol/exporting.py
--- ../pymol/modules/pymol/exporting.py	2008-11-12 11:39:00.000000000 -0500
+++ ./modules/pymol/exporting.py	2008-11-12 12:09:26.000000000 -0500
@@ -291,6 +291,56 @@
         if _self._raising(r,_self): raise QuietException
         return r
 
+#PYMOLSERVER
+    def bmp(filename, width=0, height=0, dpi=-1.0, ray=0, quiet=1, prior=0, _self=cmd):
+        '''
+DESCRIPTION
+
+    "bmp" writes a bmp format image file of the current image to disk.
+
+USAGE
+
+     bmp filename [, width [, height [, dpi [, ray]]]]
+
+ARGUMENTS
+
+    filename = string: file path to be written
+    
+    width = integer: width in pixels {default: 0 (current)}
+
+    height = integer: height in pixels {default: 0 (current)}
+
+    dpi = float: dots-per-inch {default -1.0 (unspecified)}
+
+    ray = 0 or 1: should ray be run first {default: 0 (no)}
+
+EXAMPLES
+
+    bmp image.bmp
+    bmp image.bmp, dpi=300
+
+PYMOL API
+
+    cmd.bmp(string filename, int width, int height, float dpi,
+            int ray, int quiet)
+        '''
+        r = DEFAULT_ERROR
+        prior = int(prior)
+        if prior: 
+            # fetch the prior image, without doing any work (fast-path / non-GLUT thread-safe)
+            r = _self._bmp(str(filename),0,0,float(dpi),0,int(quiet),1,_self) 
+            if r != 1: # no prior image available -- revert to default behavior
+                if prior < 0: # default is to fall back to actual rendering
+                    prior = 0
+        if not prior:
+            if thread.get_ident() == pymol.glutThread:
+                r = _self._bmp(str(filename),int(width),int(height),float(dpi),int(ray),int(quiet),0,_self)
+            else:
+                r = _self._do("cmd._bmp('%s',%d,%d,%1.6f,%d,%d)"%(filename,width,height,dpi,ray,quiet),_self=_self)
+        if _self._raising(r,_self): raise QuietException
+        return r
+#PYMOLSERVER
+
     def export_coords(obj,state,_self=cmd): # experimental
         r = DEFAULT_ERROR
         try:
diff -wb -u -r ../pymol/modules/pymol/internal.py ./modules/pymol/internal.py
--- ../pymol/modules/pymol/internal.py	2008-11-12 11:39:00.000000000 -0500
+++ ./modules/pymol/internal.py	2008-11-12 12:09:26.000000000 -0500
@@ -451,6 +451,26 @@
         _self.unlock(-1,_self)
     return r
 
+# PYMOLSERVER
+# BMP save image support *NJK*
+# writing BMP files (thread-unsafe)
+
+def _bmp(a,width=0,height=0,dpi=-1.0,ray=0,quiet=1,prior=0,_self=cmd):
+    # INTERNAL - can only be safely called by GLUT thread (unless prior == 1)
+    # WARNING: internal routine, subject to change
+    try:
+        _self.lock(_self)   
+        fname = a
+        if not re.search("\.bmp$",fname):
+            if a[0:1] != chr(1): # not an encoded file descriptor (integer)
+                fname = fname +".bmp"
+        fname = cmd.exp_path(fname)
+        r = _cmd.bmp(_self._COb,str(fname),int(width),int(height),float(dpi),int(ray),int(quiet),int(prior))
+    finally:
+        _self.unlock(-1,_self)
+    return r
+#PYMOLSERVER        
+        
 # quitting (thread-specific)
 
 def _quit(_self=cmd):
diff -wb -u -r ../pymol/modules/pymol/keywords.py ./modules/pymol/keywords.py
--- ../pymol/modules/pymol/keywords.py	2008-11-12 11:39:00.000000000 -0500
+++ ./modules/pymol/keywords.py	2008-11-12 12:09:26.000000000 -0500
@@ -23,6 +23,10 @@
         'attach'        : [ self_cmd.attach            , 0 , 0 , ''  , parsing.STRICT ],
         'backward'      : [ self_cmd.backward          , 0 , 0 , ''  , parsing.STRICT ],
         'bg_color'      : [ self_cmd.bg_color          , 0 , 0 , ''  , parsing.STRICT ],
+#PYMOLSERVER
+# BMP save image support *NJK*
+        'bmp'           : [ self_cmd.bmp               , 0 , 0 , ''  , parsing.SECURE ], 
+#PYMOLSERVER
         'bond'          : [ self_cmd.bond              , 0 , 0 , ''  , parsing.STRICT ],
         'break'         : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],   
         'button'        : [ self_cmd.button            , 0 , 0 , ''  , parsing.STRICT ],
@@ -257,6 +261,10 @@
         'vdw_fit'       : [ self_cmd.vdw_fit           , 0 , 0 , ''  , parsing.STRICT ],   
         'view'          : [ self_cmd.view              , 0 , 0 , ''  , parsing.STRICT ],   
         'viewport'      : [ self_cmd.viewport          , 0 , 0 , ''  , parsing.STRICT ],
+#PYMOLSERVER
+# Virtual mouse support *NJK*
+        'vmouse'        : [ self_cmd.vmouse            , 0 , 0 , ''  , parsing.STRICT ], 
+#PYMOLSEVER
         'window'        : [ self_cmd.window            , 0 , 0 , ''  , parsing.STRICT ],         
         'while'         : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],   
         'wizard'        : [ self_cmd.wizard            , 0 , 0 , ''  , parsing.STRICT ],
