diff -r -u '--exclude=.svn' ./contrib/uiuc/plugins/molfile_plugin/src/periodic_table.h ../pymol/contrib/uiuc/plugins/molfile_plugin/src/periodic_table.h
--- ./contrib/uiuc/plugins/molfile_plugin/src/periodic_table.h	2009-03-14 16:46:51.000000000 -0400
+++ ../pymol/contrib/uiuc/plugins/molfile_plugin/src/periodic_table.h	2011-11-16 15:43:02.000000000 -0500
@@ -75,6 +75,9 @@
     /* S  */ 1.8, 2.27, 1.88, 1.76, 1.37, 2.0,
     /* Ti */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,
     /* Ni */ 1.63, 1.4, 1.39, 1.07, 2.0, 1.85,
+    /* PYMOLSERVER */
+    /* Ni */ 1.63, 1.4, 1.39, 1.87, 2.0, 1.85, /* gah - changed Ga radius */
+    /* PYMOLSERVER */
     /* Se */ 1.9, 1.85, 2.02, 2.0, 2.0, 2.0, 
     /* Zr */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,
     /* Pd */ 1.63, 1.72, 1.58, 1.93, 2.17, 2.0, 
diff -r -u '--exclude=.svn' ./layer0/Makefile.am ../pymol/layer0/Makefile.am
--- ./layer0/Makefile.am	2011-04-22 18:30:23.000000000 -0400
+++ ../pymol/layer0/Makefile.am	2011-11-16 15:43:03.000000000 -0500
@@ -57,6 +57,8 @@
 Raw.h  \
 Shader.c \
 Shader.h \
+ShaderMgr.c \
+ShaderMgr.h \
 Sphere.c  \
 SphereData.h  \
 Sphere.h  \
diff -r -u '--exclude=.svn' ./layer0/MyPNG.c ../pymol/layer0/MyPNG.c
--- ./layer0/MyPNG.c	2011-07-20 17:19:52.000000000 -0400
+++ ../pymol/layer0/MyPNG.c	2011-11-16 15:43:03.000000000 -0500
@@ -46,7 +46,7 @@
 #  define png_jmpbuf(png_ptr) ((png_ptr)->jmpbuf)
 #endif
 
-#endif
+#endif	/* _PYMOL_LIBPNG */
 
 #include"os_std.h"
 
@@ -55,6 +55,102 @@
 #include"MemoryDebug.h"
 #include "Setting.h"
 
+/* PYMOLSERVER */
+#ifdef _PYMOL_LIBPNG
+struct PngWriteBuffer_ {
+    unsigned char *bytes;
+    size_t allocated;
+    size_t used;
+};
+
+/* PNG/PPM stdout support *NJK */
+/* add ability to write PNG/PPM files to standard output    */
+
+static void
+PngWriteDataProc(png_structp png_ptr, png_bytep buf, png_size_t numBytes)
+{
+    void *write_io_ptr;
+    struct PngWriteBuffer_ *bufPtr;
+    size_t avail;
+    
+    write_io_ptr = png_get_io_ptr(png_ptr);
+    bufPtr = write_io_ptr;
+    avail = bufPtr->allocated - bufPtr->used;
+    
+    if (numBytes > avail) {
+	size_t size, wanted;
+	unsigned char *bytes;
+
+	if (bufPtr->allocated == 0) {
+	    bufPtr->allocated = 1<<16;	/* Start with a 64K size. */
+	}
+	size = bufPtr->allocated; 
+
+	/* 
+	 * Keep doubling the buffer size until we have enough room.
+	 */
+	wanted = bufPtr->used + numBytes;
+	while (size < wanted) {
+	    size += size;
+	}    
+	if (bufPtr->bytes == NULL) {
+	    bytes = malloc(size);
+	} else {
+	    bytes = realloc(bufPtr->bytes, size);
+	}
+	if (bytes == NULL) {
+	    fprintf(stderr, "png allocation failed\n");
+	    return;
+	}
+	bufPtr->bytes = bytes;
+	bufPtr->allocated = size;
+    }
+    memcpy(bufPtr->bytes + bufPtr->used, buf, numBytes);
+    bufPtr->used += numBytes;
+    return;
+}
+
+static void
+PngFlushDataProc(png_structp png_ptr)
+{
+    return;
+}
+#endif /* _PYMOL_LIBPNG */
+
+/* 
+ * GetPrintToken --
+ *
+ *	Extract the token from the file name.  The file name isn't a
+ *	real file name but a token to be included with the header of
+ *	the images written back to stdout.  The file name is in
+ *	the form
+ *		-:<id>:<frame>:<rock>.png
+ *
+ *	id	Either a number of a tag signifying the id for the
+ *		print out.  
+ *	frame	Number of the frame.
+ *	rock	Offset of the rock.
+ *
+ *	Replaces the colons with spaces and trims off the .png extension.
+ */
+static void
+GetPrintToken(const char *fileName, char *token)
+{
+    char *sp, *dp;
+
+    /* Convert colons to spaces and stop when we find a period. */
+    for (dp = token, sp = fileName; (*sp != '\0') && (*sp != '.'); sp++, dp++) {
+	if (*sp == ':') {
+	    *dp = ' ';
+	} else {
+	    *dp = *sp;
+	}
+    }
+    *dp = '\0';
+    return token;
+}
+/* PYMOLSERVER */
+
 int MyPNGWrite(PyMOLGlobals * G, char *file_name, unsigned char *data_ptr,
                unsigned int width, unsigned int height, float dpi, int format, int quiet)
 {
@@ -62,34 +158,49 @@
   case cMyPNG_FormatPNG:
     {
 #ifdef _PYMOL_LIBPNG
+      png_struct *png_ptr;
+      png_info *info_ptr;
+      /* PYMOLSERVER */
+      struct PngWriteBuffer_ buf;
+      /* PYMOLSERVER */
       int ok = true;
       FILE *fp = NULL;
-      png_structp png_ptr;
-      png_infop info_ptr;
       int bit_depth = 8;
       int bytes_per_pixel = 4;
       png_uint_32 k;
-      png_byte *image = (png_byte *) data_ptr;
-      png_bytep *row_pointers;
+      png_byte **row_pointers;
       int fd = 0;
+      char token[200];
 
-      row_pointers = Alloc(png_bytep, height);
-
+      png_ptr = NULL;
+      info_ptr = NULL;
+      row_pointers = NULL;
+      memset(&buf, 0, sizeof(buf));
       /* open the file, allowing use of an encoded file descriptor, with
          approach adapted from TJO: chr(1) followed by ascii-format integer */
-      if(file_name[0] == 1) {
-        if(sscanf(file_name + 1, "%d", &fd) == 1) {
-          fp = fdopen(fd, "wb");
-        }
+
+      /* PYMOLSERVER */
+      if ((file_name[0] == '-') && (file_name[1] == ':')) {
+	  char *p, *s;
+
+	  fp = stdout;			/* PNG stdout support */
+	  GetPrintToken(file_name + 2, token);
       } else {
-        fp = fopen(file_name, "wb");
-      }
-      if(fp == NULL) {
-        ok = false;
-        goto cleanup;
-      } else if(feof(fp)) {
-        ok = false;
-        goto cleanup;
+      /* PYMOLSERVER */
+	  if(file_name[0] == 1) {
+	      if(sscanf(file_name + 1, "%d", &fd) == 1) {
+		  fp = fdopen(fd, "wb");
+	      }
+	  } else {
+	      fp = fopen(file_name, "wb");
+	  }
+	  if(fp == NULL) {
+	      ok = false;
+	      goto cleanup;
+	  } else if(feof(fp)) {
+	      ok = false;
+	      goto cleanup;
+	  }
       }
       /* Create and initialize the png_struct with the desired error handler
        * functions.  If you want to use the default stderr and longjump method,
@@ -97,7 +208,8 @@
        * the library version is compatible with the one used at compile time,
        * in case we are using dynamically linked libraries.  REQUIRED.
        */
-      png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+      png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, 
+	NULL);
 
       if(png_ptr == NULL) {
         ok = false;
@@ -107,7 +219,6 @@
       /* Allocate/initialize the image information data.  REQUIRED */
       info_ptr = png_create_info_struct(png_ptr);
       if(info_ptr == NULL) {
-        png_destroy_write_struct(&png_ptr, (png_infopp) NULL);
         ok = false;
         goto cleanup;
       }
@@ -117,24 +228,32 @@
        */
       if(setjmp(png_jmpbuf(png_ptr))) {
         /* If we get here, we had a problem reading the file */
-        png_destroy_write_struct(&png_ptr, (png_infopp) NULL);
         ok = false;
         goto cleanup;
       }
 
       /* set up the output control if you are using standard C streams */
-      png_init_io(png_ptr, fp);
+      /* PYMOLSERVER */
+      if (fp == stdout) {		/* PNG stdout support *NJK* */
+	  png_set_write_fn(png_ptr, &buf, PngWriteDataProc, PngFlushDataProc);
+	  png_set_compression_level(png_ptr, 1); /* Z_BEST_SPEED */
+      } else {
+	  png_init_io(png_ptr, fp);
+      }
+      /* PYMOLSERVER */
 
       /* Set the image information here.  Width and height are up to 2^31,
-       * bit_depth is one of 1, 2, 4, 8, or 16, but valid values also depend on
-       * the color_type selected. color_type is one of PNG_COLOR_TYPE_GRAY,
-       * PNG_COLOR_TYPE_GRAY_ALPHA, PNG_COLOR_TYPE_PALETTE, PNG_COLOR_TYPE_RGB,
-       * or PNG_COLOR_TYPE_RGB_ALPHA.  interlace is either PNG_INTERLACE_NONE or
-       * PNG_INTERLACE_ADAM7, and the compression_type and filter_type MUST
-       * currently be PNG_COMPRESSION_TYPE_BASE and PNG_FILTER_TYPE_BASE. REQUIRED
+       * bit_depth is one of 1, 2, 4, 8, or 16, but valid values also depend
+       * on the color_type selected. color_type is one of PNG_COLOR_TYPE_GRAY,
+       * PNG_COLOR_TYPE_GRAY_ALPHA, PNG_COLOR_TYPE_PALETTE,
+       * PNG_COLOR_TYPE_RGB, or PNG_COLOR_TYPE_RGB_ALPHA.  interlace is either
+       * PNG_INTERLACE_NONE or PNG_INTERLACE_ADAM7, and the compression_type
+       * and filter_type MUST currently be PNG_COMPRESSION_TYPE_BASE and
+       * PNG_FILTER_TYPE_BASE. REQUIRED
        */
-      png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth, PNG_COLOR_TYPE_RGB_ALPHA,
-                   PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
+      png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth, 
+		   PNG_COLOR_TYPE_RGB_ALPHA, PNG_INTERLACE_NONE, 
+		   PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
 
       if(dpi > 0.0F) {          /* only set resolution if dpi is positive */
         int dots_per_meter = (int) (dpi * 39.3700787);
@@ -162,7 +281,7 @@
         text.compression = PNG_TEXT_COMPRESSION_NONE;
         text.key = (png_charp) "URL";
         text.text = (png_charp) "http://www.pymol.org";
-        text.text_length = 5;
+        text.text_length = strlen(text.text);
         png_set_text(png_ptr, info_ptr, &text, 1);
       }
 
@@ -173,62 +292,122 @@
        * layout, however, so choose what fits your needs best).  You need to
        * use the first method if you aren't handling interlacing yourself.
        */
-      for(k = 0; k < height; k++)
-        row_pointers[(height - k) - 1] = image + k * width * bytes_per_pixel;
+      {
+	  unsigned char *srcRowPtr;
+	  int k;
 
-      png_write_image(png_ptr, row_pointers);
+	  row_pointers = Alloc(png_bytep, height);
+	  srcRowPtr = data_ptr;
+	  for(k = height - 1; k >= 0; k--) {
+	      row_pointers[k] = srcRowPtr;
+	      srcRowPtr += width * bytes_per_pixel;
+	  }
+	  png_write_image(png_ptr, row_pointers);
+	  FreeP(row_pointers);
+      }
 
       /* It is REQUIRED to call this to finish writing the rest of the file */
       png_write_end(png_ptr, info_ptr);
 
       /* clean up after the write, and free any memory allocated */
-      png_destroy_write_struct(&png_ptr, (png_infopp) NULL);
-
     cleanup:
-      if(fp) {
-        /* close the file */
-        fclose(fp);
+      if (info_ptr != NULL) {
+	  png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
       }
-
-      mfree(row_pointers);
+      if (png_ptr != NULL) {
+	  png_destroy_write_struct(&png_ptr, (png_info **)NULL);
+      }
+      /* PYMOLSERVER */
+      if ((ok) && (fp == stdout)) {		/* Stdout image patch *NJK */
+	  fprintf(fp, "image follows: %d %s\n", buf.used, token);
+	  fwrite(buf.bytes, sizeof(char), buf.used, fp);
+	  fflush(fp);
+	  if (buf.bytes != NULL) {
+	      free(buf.bytes);
+	  }
+      } else {
+	  if(fp) {
+	      /* close the file */
+	      fclose(fp);
+	  }
+      }
+      /* PYMOLSERVER */
       /* that's it */
 
       return ok;
 #else
-
       return 0;
-#endif
+#endif	/* _PYMOL_LIBPNG */
     }
     break;
   case cMyPNG_FormatPPM:
     {
-      FILE *fil = fopen(file_name, "wb");
-      unsigned char *buffer = Alloc(unsigned char, 3 * width * height);
-
-      if(fil && buffer) {
-        fprintf(fil, "P6\n");
-        fprintf(fil, "%d %d\n", width, height);
-        fprintf(fil, "255\n");
-        {
-          int a, b;
-          unsigned char *q = buffer, *p;
-          p = data_ptr + width * 4 * (height - 1);
-          for(b = 0; b < height; b++) {
-            for(a = 0; a < width; a++) {
-              *(q++) = *(p++);  /* platform-specific ordering? */
-              *(q++) = *(p++);
-              *(q++) = *(p++);
-              p++;
-            }
-            p -= width * 8;
-          }
-          fwrite(buffer, width, height * 3, fil);
-        }
-      }
-      if(fil) {
-        fclose(fil);
-      }
-      FreeP(buffer);
+	/* PYMOLSERVER */
+        if ((file_name[0] == '-') && (file_name[1] == ':')) {
+	    FILE *fp;
+	    char header[200];
+	    char token[200];
+	    char *s, *p;
+	    size_t numBytes, srcBytesPerRow, destBytesPerRow;
+	    unsigned char *srcRowPtr, *destRowPtr, *bytes;
+	    int y;
+	    
+	    GetPrintToken(file_name + 2, token);
+	    numBytes = width * height * 3;
+	    bytes = Alloc(unsigned char, numBytes);
+	    sprintf(header, "P6\n%d %d\n255\n", width, height);
+	    fprintf(stdout, "image follows: %lu %s\n%s", 
+		    numBytes + strlen(header), token, header);
+	    srcBytesPerRow = width * 4;
+	    destBytesPerRow = width * 3;
+	    destRowPtr = bytes;
+	    srcRowPtr = data_ptr + srcBytesPerRow * (height-1);
+	    for (y = 0; y < height; y++) {
+		unsigned char *dp, *dend, *sp;
+		sp = srcRowPtr;
+		
+		for (dp = destRowPtr, dend = dp + destBytesPerRow; dp < dend; 
+		     dp += 3, sp += 4) {
+		    dp[0] = sp[0];  
+		    dp[1] = sp[1];
+		    dp[2] = sp[2];
+		}			
+		srcRowPtr -= srcBytesPerRow;
+		destRowPtr += destBytesPerRow;
+	    }
+	    fwrite(bytes, 1, numBytes, stdout);
+	    fflush(stdout);
+	    FreeP(bytes);
+	} else {
+	    FILE *fil=fopen(file_name,"wb");
+	    unsigned char *buffer = Alloc(unsigned char,3*width*height);
+	    
+	    if(fil && buffer) {
+		fprintf(fil,"P6\n");
+		fprintf(fil,"%d %d\n",width, height);
+		fprintf(fil,"255\n");
+		{
+		    int a,b;
+		    unsigned char *q = buffer, *p;
+		    p = data_ptr + width * 4 * (height-1);
+		    for(b=0;b<height;b++) {
+			for(a=0;a<width;a++) {
+			    *(q++) = *(p++);  /* platform-specific ordering? */
+			    *(q++) = *(p++);
+			    *(q++) = *(p++);
+			    p++;
+			}
+			p -= width * 8;
+		    }
+		    fwrite(buffer,width,height*3,fil);
+		}
+	    }
+	    if(fil) {
+		fclose(fil);
+	    }
+	    FreeP(buffer);
+	}      
+	/* PYMOLSERVER */
     }
     return 1;
     break;
diff -r -u '--exclude=.svn' ./layer0/PyMOLGlobals.h ../pymol/layer0/PyMOLGlobals.h
--- ./layer0/PyMOLGlobals.h	2011-04-22 18:30:23.000000000 -0400
+++ ../pymol/layer0/PyMOLGlobals.h	2011-11-16 15:43:03.000000000 -0500
@@ -178,6 +178,9 @@
 #endif
 };
 
+/* PYMOLSERVER */
+extern int gCmdPipe[2];			/* Sleep Interruption Patch *NJK* */
+/* PYMOLSERVER */
 
 /* if we're running PyMOL as a global singleton (old way / backward
    compatible) then this global variable will contain a pointer to
diff -r -u '--exclude=.svn' ./layer1/Ortho.c ../pymol/layer1/Ortho.c
--- ./layer1/Ortho.c	2011-07-20 17:19:52.000000000 -0400
+++ ../pymol/layer1/Ortho.c	2011-11-16 15:43:03.000000000 -0500
@@ -2373,6 +2373,12 @@
   register COrtho *I = G->Ortho;
   if(I->cmdActiveQueue)
     QueueStrIn(I->cmdActiveQueue, buffer);
+  /* PYMOLSERVER */
+  {
+      char c = 1;			/* Sleep Interruption Patch *NJK* */
+      write(gCmdPipe[1], &c, 1);	
+  }
+  /* PYMOLSERVER */
 }
 
 
diff -r -u '--exclude=.svn' ./layer1/P.c ../pymol/layer1/P.c
--- ./layer1/P.c	2011-07-20 17:19:52.000000000 -0400
+++ ../pymol/layer1/P.c	2011-11-16 15:43:03.000000000 -0500
@@ -722,7 +722,21 @@
     " PSleep-DEBUG: napping.\n" ENDFD;
   tv.tv_sec = 0;
   tv.tv_usec = usec;
-  select(0, NULL, NULL, NULL, &tv);
+
+  /* PYMOLSERVER */
+  {
+      /* Sleep Interruption Patch *NJK* */
+      fd_set readFds;			
+
+      FD_ZERO(&readFds);
+      FD_SET(gCmdPipe[0], &readFds);
+      select(gCmdPipe[0]+1, &readFds, NULL, NULL, &tv);
+      if (FD_ISSET(gCmdPipe[0], &readFds)) {
+	  char c;
+	  read(gCmdPipe[0], &c, 1);
+      }
+  }
+  /* PYMOLSERVER */
   PRINTFD(G, FB_Threads)
     " PSleep-DEBUG: nap over.\n" ENDFD;
 #else
diff -r -u '--exclude=.svn' ./layer2/AtomInfo.c ../pymol/layer2/AtomInfo.c
--- ./layer2/AtomInfo.c	2011-07-20 17:19:52.000000000 -0400
+++ ../pymol/layer2/AtomInfo.c	2011-11-16 15:43:04.000000000 -0500
@@ -32,6 +32,10 @@
 #include"OVContext.h"
 #include"PyMOLObject.h"
 
+/*PYMOLSERVER*/
+static int RapptureGetVDWRadius(const char *symbol, float *radiusPtr);
+/*PYMOLSERVER*/
+
 struct _CAtomInfo {
   int NColor, CColor, DColor, HColor, OColor, SColor;
   int BrColor, ClColor, FColor, IColor;
@@ -3859,9 +3863,15 @@
     vdw = 1.86F;
     break;
 
-  case cAN_LP:
-    vdw = 0.5F;
-    break;                      /* lone pairs @ 0.5 same as MOE? */
+  case cAN_LP: 
+    /*PYMOLSERVER*/
+    vdw=1.70F;				/* gah@purdue: Setting default radius
+					 * to 1.7 (same as carbon).  Previous
+					 * setting of 0.5 is too small
+					 * (especially with 0.25 sphere
+					 * scale). */
+    /*PYMOLSERVER*/
+    break; 
 
   default:
     vdw = 1.80F;
@@ -3890,6 +3900,11 @@
     if(!strcmp(e, "H"))
       vdw = 1.1F;
   }
+  /*PYMOLSERVER*/
+  /* This routine overrides the current radius value if it can find a matching
+   * element symbol. */
+  RapptureGetVDWRadius(e, &vdw);
+  /*PYMOLSERVER*/
 
   if(I->vdw == 0.0)             /* only assigned if not yet assigned */
     I->vdw = vdw;
@@ -3903,3 +3918,207 @@
     I->hydrogen = true;
   /*  printf("I->name %s I->priority %d\n",I->name,I->priority); */
 }
+
+/*PYMOLSERVER*/
+/* 
+ *
+ * RapptureGetVDWRadius --
+ *
+ *	Get the van der Waals radius of the atom given the element symbol
+ *	(e.g. "Pb"). The values are taken from wikipedia (reference
+ *	http://www.webelements.com).
+ *
+ *	gah@purdue.edu: Several atoms (e.g. Ga, As) did not have a van der
+ *	Waals radius listed by default in pymol.  They defaulted to 0.5.  That
+ *	in conjunction with the setting of sphere_scale to 0.25 made the
+ *	spheres for these atoms too tiny to see.
+ *
+ *	Performs a binary search to lookup symbols and their corresponding
+ *	radii.
+ */
+struct VdwRadii {
+    char *symbol;
+    float radius;
+};
+
+static struct VdwRadii vdwRadii[] = {
+    /* The rows in the this table must be sorted alphabetically low to high by
+     * the element symbol. */
+    "Ac",       2.00f,
+    "Ag",       1.72f,
+    "Ag",       1.72f,
+    "Al",       2.00f,
+    "Am",       2.00f,
+    "Ar",       1.88f,
+    "Ar",       1.88f,
+    "As",       1.85f,
+    "As",       1.85f,
+    "At",       2.00f,
+    "Au",       1.66f,
+    "Au",       1.66f,
+    "B",        2.00f,
+    "Ba",       2.00f,
+    "Be",       2.00f,
+    "Bh",       2.00f,
+    "Bi",       2.00f,
+    "Bk",       2.00f,
+    "Br",       1.85f,
+    "Br",       1.85f,
+    "C",        1.70f,
+    "C",        1.70f,
+    "Ca",       2.00f,
+    "Cd",       1.58f,
+    "Cd",       1.58f,
+    "Ce",       2.00f,
+    "Cf",       2.00f,
+    "Cl",       1.75f,
+    "Cl",       1.75f,
+    "Cm",       2.00f,
+    "Co",       2.00f,
+    "Cr",       2.00f,
+    "Cs",       2.00f,
+    "Cu",       1.40f,
+    "Cu",       1.40f,
+    "Db",       2.00f,
+    "Ds",       2.00f,
+    "Dy",       2.00f,
+    "Er",       2.00f,
+    "Es",       2.00f,
+    "Eu",       2.00f,
+    "F",        1.47f,
+    "F",        1.47f,
+    "Fe",       2.00f,
+    "Fe",       2.00f,
+    "Fm",       2.00f,
+    "Fr",       2.00f,
+    "Ga",       1.87f,
+    "Ga",       1.87f,
+    "Gd",       2.00f,
+    "Ge",       2.00f,
+    "H",        1.09f,
+    "H",        1.20f,  
+    "He",       1.40f,
+    "He",       1.40f,  
+    "Hf",       2.00f,
+    "Hg",       1.55f,
+    "Hg",       1.55f,
+    "Ho",       2.00f,
+    "Hs",       2.00f,
+    "I",        1.98f,
+    "I",        1.98f,
+    "In",       1.93f,
+    "In",       1.93f,
+    "Ir",       2.00f,
+    "K",        2.75f,
+    "K",        2.75f,
+    "Kr",       2.02f,
+    "Kr",       2.02f,
+    "La",       2.00f,
+    "Li",       1.82f,
+    "Li",       1.82f,
+    "Lr",       1.50f,
+    "Lu",       2.00f,
+    "Md",       2.00f,
+    "Mg",       1.73f,
+    "Mg",       1.73f,
+    "Mn",       2.00f,
+    "Mo",       2.00f,
+    "Mt",       2.00f,
+    "N",        1.55f,
+    "N",        1.55f,
+    "Na",       2.27f,
+    "Na",       2.27f,
+    "Nb",       2.00f,
+    "Nd",       2.00f,
+    "Ne",       1.54f,
+    "Ne",       1.54f,
+    "Ni",       1.63f,
+    "Ni",       1.63f,
+    "No",       2.00f,
+    "Np",       2.00f,
+    "O",        1.52f,
+    "O",        1.52f,
+    "Os",       2.00f,
+    "P",        1.80f,
+    "P",        1.80f,
+    "Pa",       2.00f,
+    "Pb",       2.02f,
+    "Pb",       2.02f,
+    "Pd",       1.63f,
+    "Pd",       1.63f,
+    "Pm",       2.00f,
+    "Po",       2.00f,
+    "Pr",       2.00f,
+    "Pt",       1.72f,
+    "Pt",       1.75f,
+    "Pu",       2.00f,
+    "Ra",       2.00f,
+    "Rb",       2.00f,
+    "Re",       2.00f,
+    "Rf",       2.00f,
+    "Rh",       2.00f,
+    "Rn",       2.00f,
+    "Ru",       2.00f,
+    "S",        1.80f,
+    "S",        1.80f,
+    "Sb",       2.00f,
+    "Sc",       2.00f,
+    "Se",       1.90f,
+    "Se",       1.90f,
+    "Sg",       2.00f,
+    "Si",       2.10f,
+    "Si",       2.10f,
+    "Sm",       2.00f,
+    "Sn",       2.17f,
+    "Sn",       2.17f,
+    "Sr",       2.00f,
+    "Ta",       2.00f,
+    "Tb",       2.00f,
+    "Tc",       2.00f,
+    "Te",       2.06f,
+    "Te",       2.06f,
+    "Th",       2.00f,
+    "Ti",       2.00f,
+    "Tl",       1.96f,
+    "Tl",       1.96f,
+    "Tm",       2.00f,
+    "U",        1.86f,
+    "U",        1.86f,
+    "V",        2.00f,
+    "W",        2.00f,
+    "Xe",       2.16f,
+    "Xe",       2.16f,
+    "Y",        2.00f,
+    "Yb",       2.00f,
+    "Zn",       1.39f,
+    "Zn",       1.39f,
+    "Zr",       2.00f
+};
+
+static int nVdwRadii = sizeof(vdwRadii) / sizeof(struct VdwRadii);
+
+static int
+RapptureGetVDWRadius(const char *symbol, float *radiusPtr) 
+{
+    int low, high;
+    
+    low = 0;
+    high = nVdwRadii - 1;
+    while (low <= high) {
+	int median, result;
+
+	median = (low + high) >> 1;
+	result = strcmp(symbol, vdwRadii[median].symbol);
+	if (result < 0) {
+	    high = median - 1;
+	} else if (result > 0) {
+	    low = median + 1;
+	} else {
+	    *radiusPtr = vdwRadii[median].radius;
+	    return 1;
+	}
+    }
+    return 0;
+}
+
+/*PYMOLSERVER*/
diff -r -u '--exclude=.svn' ./layer3/Makefile.in ../pymol/layer3/Makefile.in
--- ./layer3/Makefile.in	2009-07-07 14:59:21.000000000 -0400
+++ ../pymol/layer3/Makefile.in	2011-11-16 15:43:04.000000000 -0500
@@ -201,7 +201,8 @@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 INCLUDES = -I../ov/src -I../layer0 -I../layer1 -I../layer2 \
-   -I../layer4 -I../layer5 -I../contrib/uiuc/plugins/include
+   -I../layer4 -I../layer5 -I../contrib/uiuc/plugins/include \
+   -I../modules/cealign/src
 
 noinst_LTLIBRARIES = liblayer3.la
 liblayer3_la_SOURCES = Editor.c \
diff -r -u '--exclude=.svn' ./layer4/Cmd.c ../pymol/layer4/Cmd.c
--- ./layer4/Cmd.c	2011-07-20 17:19:52.000000000 -0400
+++ ../pymol/layer4/Cmd.c	2011-11-16 15:43:04.000000000 -0500
@@ -6275,6 +6275,38 @@
   return APIResultCode(result);
 }
 
+/*PYMOLSERVER*/
+/* Virtual Mouse command *NJK* */
+static PyObject *
+CmdVMouse(PyObject *self, PyObject *args)
+{
+    PyMOLGlobals *G = NULL;
+    int ok = false;
+    int button, modifier, state, x, y;
+    int quiet;
+    int result = 0;
+    ok = PyArg_ParseTuple(args,"iiiii",&button,&modifier,&state,&x,&y,&quiet);
+    
+    if(ok) {
+	API_SETUP_PYMOL_GLOBALS;
+	ok = (G!=NULL);
+    }
+    if(ok && (ok=APIEnterNotModal(G))) {
+	if ((state == 0) || (state == 1))
+	    ProcessMainButton(button,modifier,state,x,y);
+	else if (state == 2)
+	    ProcessMainDrag(x,y);
+	else if (state == 3)
+	    ProcessMainPassive(x,y);
+	APIExit(G);
+    }
+    if(!ok)
+	result = -1;
+    return APIResultCode(result);
+}
+/*PYMOLSERVER*/
+
+
 static PyObject *CmdMPNG(PyObject * self, PyObject * args)
 {
   PyMOLGlobals *G = NULL;
@@ -9112,6 +9144,9 @@
   {"unset", CmdUnset, METH_VARARGS},
   {"unset_bond", CmdUnsetBond, METH_VARARGS},
   {"update", CmdUpdate, METH_VARARGS},
+  /*PYMOLSERVER*/
+  {"vmouse", CmdVMouse, METH_VARARGS},  /* Virtual Mouse command *NJK* */
+  /*PYMOLSERVER*/
   {"window", CmdWindow, METH_VARARGS},
   {"zoom", CmdZoom, METH_VARARGS},
   {NULL, NULL}                  /* sentinel */
diff -r -u '--exclude=.svn' ./layer5/PyMOL.c ../pymol/layer5/PyMOL.c
--- ./layer5/PyMOL.c	2011-07-20 17:19:52.000000000 -0400
+++ ../pymol/layer5/PyMOL.c	2011-11-16 15:43:04.000000000 -0500
@@ -71,6 +71,9 @@
 PyMOLGlobals *SingletonPyMOLGlobals = NULL;
 #endif
 
+/* PYMOLSERVER */
+int gCmdPipe[2];
+/* PYMOLSERVER */
 
 /* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
 #ifndef _PYMOL_NOPY
@@ -3376,6 +3379,10 @@
 
       result->G->PyMOL = result;        /* store the instance pointer */
 
+      /*PYMOLSERVER*/
+      pipe(gCmdPipe);			/* Sleep Interruption Patch *NJK* */
+      /*PYMOLSERVER*/
+
       result->BusyFlag = false;
       result->InterruptFlag = false;
       PyMOL_ResetProgress(result);
diff -r -u '--exclude=.svn' ./layer5/main.c ../pymol/layer5/main.c
--- ./layer5/main.c	2011-07-20 17:19:52.000000000 -0400
+++ ../pymol/layer5/main.c	2011-11-16 15:43:04.000000000 -0500
@@ -611,6 +611,101 @@
   }
 }
 
+/*PYMOLSERVER*/
+/*========================================================================*/
+/* Virtual mouse support *NJK* */
+void 
+ProcessMainDrag(int x,int y)
+{
+    PyMOLGlobals *G = SingletonPyMOLGlobals;
+    
+    CMain *I = G->Main;
+    
+    y=G->Option->winY-y;
+    
+    PyMOL_Drag(PyMOLInstance,x,y,I->Modifiers);
+    
+    if(PyMOL_GetRedisplay(PyMOLInstance, true)) {
+	if(G->HaveGUI) {
+	    p_glutPostRedisplay();
+	}
+	I->IdleMode = 0;
+    }
+}
+
+void 
+ProcessMainButton(int button,int glMod,int state,int x,int y)
+{
+    PyMOLGlobals *G = SingletonPyMOLGlobals;
+    
+    CMain *I = G->Main;
+    
+    I->IdleMode = 0; /* restore responsiveness */
+    
+    if(PyMOL_GetPassive(PyMOLInstance, true)) {
+	ProcessMainDrag(x,y);
+    } else {
+	/* stay blocked here because Clicks->SexFrame->PParse */
+	
+	y=G->Option->winY-y;
+	
+	I->Modifiers = ((glMod&P_GLUT_ACTIVE_SHIFT) ? cOrthoSHIFT : 0) |
+	    ((glMod&P_GLUT_ACTIVE_CTRL) ? cOrthoCTRL : 0) |
+	    ((glMod&P_GLUT_ACTIVE_ALT) ? cOrthoALT : 0);
+	
+	switch(button) {
+	case P_GLUT_BUTTON_SCROLL_FORWARD:
+	case P_GLUT_BUTTON_SCROLL_BACKWARD:
+	    x=G->Option->winX/2;
+	    y=G->Option->winY/2; /* force into scene */
+	    break;
+	}
+	PyMOL_Button(PyMOLInstance,button,state,x,y,I->Modifiers);
+    }
+}
+
+void 
+ProcessMainPassive(int x,int y)
+{
+    PyMOLGlobals *G = SingletonPyMOLGlobals;
+    CMain *I = G->Main;
+    
+#define PASSIVE_EDGE 20
+    
+    if(PyMOL_GetPassive(G->PyMOL,false)) { /* a harmless race condition -- we
+					    * don't want to slow Python down
+					    * buy locking on passive mouse
+					    * motion */
+	
+	if((y<-PASSIVE_EDGE)||(x<-PASSIVE_EDGE)||
+	   (x>(G->Option->winX+PASSIVE_EDGE))||
+	   (y>(G->Option->winY+PASSIVE_EDGE))) {       
+	    /* release passive drag if mouse leaves window... */
+	    
+	    y=G->Option->winY-y;
+	    
+	    PyMOL_Button(PyMOLInstance,P_GLUT_LEFT_BUTTON, P_GLUT_UP,x,y,
+			 I->Modifiers);
+	    
+	    PyMOL_GetPassive(G->PyMOL,true); /* reset the flag */
+	    
+	} else {
+	    
+	    y=G->Option->winY-y;
+	    
+	    PyMOL_Drag(PyMOLInstance,x,y,I->Modifiers);
+	    
+	}
+	
+	if(PyMOL_GetRedisplay(PyMOLInstance, true)) {
+	    if(G->HaveGUI) {
+		p_glutPostRedisplay();
+	    }      
+	    I->IdleMode = 0;
+	}
+    }
+}
+/*PYMOLSERVER*/
 
 /*========================================================================*/
 static void MainButton(int button, int state, int x, int y)
diff -r -u '--exclude=.svn' ./modules/pymol/api.py ../pymol/modules/pymol/api.py
--- ./modules/pymol/api.py	2011-04-01 17:22:09.000000000 -0400
+++ ../pymol/modules/pymol/api.py	2011-11-16 15:43:03.000000000 -0500
@@ -14,6 +14,7 @@
       load_traj,          \
       load_raw,           \
       loadable,           \
+      loadandremovepdbfile, \
       read_mmodstr,       \
       read_molstr,        \
       read_sdfstr,        \
@@ -62,6 +63,8 @@
 
 #--------------------------------------------------------------------
 import controlling
+#PYMOLSERVER
+# vmouse adds Virutal mouse support *NJK*
 from controlling import \
       button,             \
       config_mouse,       \
@@ -70,7 +73,9 @@
       order,              \
       set_key,            \
       unmask,             \
+      vmouse,             \
       edit_mode
+#PYMOLSERVER
 
 #--------------------------------------------------------------------
 from querying import \
diff -r -u '--exclude=.svn' ./modules/pymol/controlling.py ../pymol/modules/pymol/controlling.py
--- ./modules/pymol/controlling.py	2011-04-01 17:22:09.000000000 -0400
+++ ../pymol/modules/pymol/controlling.py	2011-11-16 15:43:03.000000000 -0500
@@ -589,6 +589,18 @@
         if _self._raising(r,_self): raise pymol.CmdException                     
         return r
             
+#PYMOLSERVER
+    # Virtual mouse support *NJK*
+    def vmouse(b,m,s,x,y,quiet=1,_self=cmd):
+        r = DEFAULT_SUCCESS
+        try:
+            _self.lock(_self)   
+            _cmd.vmouse(int(b),int(m),int(s),int(x),int(y))
+        finally:
+            _self.unlock(r,_self)
+        if _self._raising(r,_self): raise pymol.CmdException         
+        return r
+#PYMOLSERVER
 
     def edit_mode(active=1,quiet=1,_self=cmd):
         '''
diff -r -u '--exclude=.svn' ./modules/pymol/importing.py ../pymol/modules/pymol/importing.py
--- ./modules/pymol/importing.py	2011-07-26 11:04:45.000000000 -0400
+++ ../pymol/modules/pymol/importing.py	2011-11-16 15:43:03.000000000 -0500
@@ -1542,3 +1542,12 @@
             t.start()
         return r
         
+#PYMOLSERVER
+    def loadandremovepdbfile(fileName, name, state):
+        cmd.load(fileName, name, state, format="pdb")
+        import os
+        try:
+            os.remove(fileName)
+        except os.error:
+            print "can't remove pdb file " + fileName
+#PYMOLSERVER        
diff -r -u '--exclude=.svn' ./modules/pymol/keywords.py ../pymol/modules/pymol/keywords.py
--- ./modules/pymol/keywords.py	2011-04-01 17:22:09.000000000 -0400
+++ ../pymol/modules/pymol/keywords.py	2011-11-16 15:43:03.000000000 -0500
@@ -130,6 +130,9 @@
         'iterate_state' : [ self_cmd.iterate_state     , 0 , 0 , ''  , parsing.LITERAL2 ], # insecure
         'label'         : [ self_cmd.label             , 0 , 0 , ''  , parsing.LITERAL1 ], # insecure
         'load'          : [ self_cmd.load              , 0 , 0 , ''  , parsing.STRICT ],
+        #PYMOLSERVER
+        'loadandremovepdbfile' : [ self_cmd.loadandremovepdbfile, 0 , 0 , ''  , parsing.STRICT ], 
+        #PYMOLSEVER
         'space'         : [ self_cmd.space             , 0 , 0 , ''  , parsing.STRICT ],
         'load_embedded' : [ self_cmd.load_embedded     , 0 , 0 , ''  , parsing.STRICT ],
         'load_png'      : [ self_cmd.load_png          , 0 , 0 , ''  , parsing.STRICT ],
@@ -268,6 +271,10 @@
         'viewport'      : [ self_cmd.viewport          , 0 , 0 , ''  , parsing.STRICT ],
         'volume'        : [ self_cmd.volume            , 0 , 0 , ''  , parsing.STRICT ],
         'volume_color'  : [ self_cmd.volume_color      , 0 , 0 , ''  , parsing.STRICT ],
+        #PYMOLSERVER
+        # Virtual mouse support *NJK*
+        'vmouse'        : [ self_cmd.vmouse            , 0 , 0 , ''  , parsing.STRICT ], 
+        #PYMOLSEVER
         'window'        : [ self_cmd.window            , 0 , 0 , ''  , parsing.STRICT ],         
         'while'         : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],   
         'wizard'        : [ self_cmd.wizard            , 0 , 0 , ''  , parsing.STRICT ],
